---
name: hosted-agents
description: このスキルは、ユーザーが「バックグラウンドエージェントを構築する」「ホスト型コーディングエージェントを作成する」「サンドボックス実行を設定する」「マルチプレイヤーエージェントを実装する」と依頼した場合、またはバックグラウンドエージェント、サンドボックスVM、エージェントインフラストラクチャ、Modalサンドボックス、自己スポーンエージェント、リモートコーディング環境に言及した場合に使用します。
---

# ホスト型エージェントインフラストラクチャ

ホスト型エージェントは、ローカルマシンではなくリモートのサンドボックス環境で実行されます。適切に設計されている場合、無制限の同時実行性、一貫した実行環境、マルチプレイヤーコラボレーションを提供します。重要な洞察は、セッション速度はモデルプロバイダーの最初のトークンまでの時間のみによって制限されるべきであり、すべてのインフラストラクチャのセットアップはユーザーがセッションを開始する前に完了していなければならないということです。

## アクティベーション条件

以下の場合にこのスキルをアクティベートしてください：
- ユーザーデバイスから独立して実行されるバックグラウンドコーディングエージェントを構築する場合
- エージェントワークロード用のサンドボックス実行環境を設計する場合
- 共有状態を持つマルチプレイヤーエージェントセッションを実装する場合
- マルチクライアントエージェントインターフェース（Slack、Web、Chrome拡張機能）を作成する場合
- ローカルマシンの制約を超えてエージェントインフラストラクチャをスケールする場合
- エージェントが並列作業のためにサブエージェントをスポーンするシステムを構築する場合

## コアコンセプト

ホスト型エージェントは、ローカルエージェント実行の根本的な制限に対処します：リソース競合、環境の不一致、シングルユーザー制約。エージェント実行をリモートのサンドボックス環境に移行することで、チームは無制限の同時実行性、再現可能な環境、コラボレーティブなワークフローを獲得します。

アーキテクチャは3つのレイヤーで構成されます：分離された実行のためのサンドボックスインフラストラクチャ、状態管理とクライアント調整のためのAPIレイヤー、プラットフォーム間でのユーザーインタラクションのためのクライアントインターフェース。各レイヤーにはシステムのスケールを可能にする特定の設計要件があります。

## 詳細トピック

### サンドボックスインフラストラクチャ

**中核的な課題**
完全な開発環境を迅速に立ち上げることが主要な技術的課題です。ユーザーはほぼ即座のセッション開始を期待しますが、開発環境にはリポジトリのクローン、依存関係のインストール、ビルドステップの実行が必要です。

**イメージレジストリパターン**
定期的なケイデンス（30分ごとが適切）で環境イメージを事前にビルドします。各イメージには以下が含まれます：
- 既知のコミット時点のクローンされたリポジトリ
- インストール済みのすべてのランタイム依存関係
- 完了した初期セットアップとビルドコマンド
- アプリとテストスイートの初回実行によるキャッシュファイル

セッション開始時には、最新のイメージからサンドボックスを起動します。リポジトリは最大30分遅れているだけなので、最新コードとの同期がはるかに高速になります。

**スナップショットとリストア**
主要なポイントでファイルシステムスナップショットを取得：
- 初期イメージビルド後（ベーススナップショット）
- エージェントが変更を完了した時（セッションスナップショット）
- フォローアップの可能性に備えたサンドボックス終了前

これにより、セットアップを再実行することなく、フォローアッププロンプトの即座のリストアが可能になります。

**バックグラウンドエージェント用Git設定**
イメージビルド中はgit操作が特定のユーザーに紐づかないため：
- クローン時のリポジトリアクセスにはGitHubアプリインストールトークンを生成
- 変更のコミットとプッシュ時にgit configの`user.name`と`user.email`を更新
- コミットにはアプリのIDではなく、プロンプトを送信したユーザーのIDを使用

**ウォームプール戦略**
高トラフィックリポジトリ用の事前ウォームされたサンドボックスのプールを維持：
- ユーザーがセッションを開始する前にサンドボックスが準備完了
- 新しいイメージビルドが完了したらプールエントリを期限切れにして再作成
- ユーザーが入力を始めたらすぐにサンドボックスのウォーミングを開始（予測的ウォームアップ）

### エージェントフレームワーク選択

**サーバーファーストアーキテクチャ**
TUIやデスクトップアプリをクライアントとし、まずサーバーとして構造化されたエージェントフレームワークを選択します。これにより以下が可能になります：
- エージェントロジックを重複させることなく複数のカスタムクライアント
- すべてのインタラクションサーフェスで一貫した振る舞い
- 機能拡張のためのプラグインシステム
- リアルタイム更新のためのイベント駆動アーキテクチャ

**ソースオブトゥルースとしてのコード**
エージェントが自身のソースコードを読んで振る舞いを理解できるフレームワークを選択します。これはAI開発において過小評価されています：コードをソースオブトゥルースとすることで、エージェント自身の機能に関するハルシネーションを防止します。

**プラグインシステム要件**
フレームワークは以下のプラグインをサポートすべきです：
- ツール実行イベントのリッスン（例：`tool.execute.before`）
- 条件付きのツール呼び出しのブロックまたは変更
- ランタイムでのコンテキストや状態の注入

### 速度最適化

**予測的ウォームアップ**
ユーザーがプロンプトの入力を始めたらすぐにサンドボックスのウォーミングを開始：
- ユーザーの入力と並行して最新の変更をクローン
- ユーザーがエンターを押す前に初期セットアップを実行
- 高速起動では、ユーザーが入力を完了する前にサンドボックスが準備完了

**並行ファイル読み取り**
最新のベースブランチからの同期が完了していなくても、エージェントがすぐにファイル読み取りを開始できるようにする：
- 大規模リポジトリでは、受信プロンプトが最近変更されたファイルを変更することはほとんどない
- エージェントはgit同期を待たずにすぐにリサーチを開始可能
- 同期完了までファイル編集（読み取りではなく）をブロック

**ビルド時間作業の最大化**
可能なすべてをイメージビルドステップに移行：
- 完全な依存関係のインストール
- データベーススキーマのセットアップ
- アプリとテストスイートの初回実行（キャッシュをポピュレート）
- ビルド時間の長さはユーザーには見えない

### 自己スポーンエージェント

**エージェントがスポーンするセッション**
エージェントが新しいセッションをスポーンできるツールを作成：
- 異なるリポジトリ間でのリサーチタスク
- 大規模な変更のための並列サブタスク実行
- 1つの大きなタスクから複数の小さなPR

フロンティアモデルは自身を制御する能力を持っています。ツールは以下をすべきです：
- 指定されたパラメータで新しいセッションを開始
- 任意のセッションのステータスを読み取り（チェックイン機能）
- サブセッションが並行実行中もメイン作業を継続

**自己スポーンのプロンプトエンジニアリング**
エージェントがサブセッションをスポーンするタイミングを導くプロンプトを設計：
- クロスリポジトリの探索を必要とするリサーチタスク
- モノリシックな変更をより小さなPRに分割
- 異なるアプローチの並列探索

### APIレイヤー

**セッションごとの状態分離**
各セッションには独立した状態ストレージが必要：
- セッションごとの専用データベース（セッションごとのSQLiteが適切）
- あるセッションが別のセッションのパフォーマンスに影響を与えない
- 数百の同時セッションを処理

**リアルタイムストリーミング**
エージェント作業には高頻度の更新が伴います：
- モデルプロバイダーからのトークンストリーミング
- ツール実行ステータスの更新
- ファイル変更通知

ハイバネーションAPIを持つWebSocket接続により、オープンな接続を維持しながらアイドル期間のコンピューティングコストを削減します。

**クライアント間の同期**
以下を同期する単一の状態システムを構築：
- チャットインターフェース
- Slackボット
- Chrome拡張機能
- Webインターフェース
- VS Codeインスタンス

すべての変更がセッション状態に同期され、シームレスなクライアント切り替えが可能になります。

### マルチプレイヤーサポート

**マルチプレイヤーが重要な理由**
マルチプレイヤーにより以下が可能：
- 非エンジニアにAIを効果的に使う方法を教える
- 複数のチームメンバーによるライブQAセッション
- 即座の変更を伴うリアルタイムPRレビュー
- コラボレーティブなデバッグセッション

**実装要件**
- データモデルはセッションを単一の著者に紐づけてはならない
- 各プロンプトに著者情報を渡す
- コード変更をプロンプトを送信したユーザーに帰属させる
- 即座のコラボレーションのためにセッションリンクを共有

適切な同期アーキテクチャがあれば、マルチプレイヤーサポートの追加はほぼ無料です。

### 認証と認可

**ユーザーベースのコミット**
GitHub認証を使用して：
- PR作成のためのユーザートークンを取得
- アプリではなくユーザーの代わりにPRを開く
- ユーザーが自身の変更を承認するのを防止

**サンドボックスからAPIへのフロー**
1. サンドボックスが変更をプッシュ（git user configを更新）
2. サンドボックスがブランチ名とセッションIDを含むイベントをAPIに送信
3. APIがユーザーのGitHubトークンを使用してPRを作成
4. GitHubウェブフックがPRイベントをAPIに通知

### クライアント実装

**Slack統合**
社内採用のための最も効果的な配信チャネル：
- チームメンバーが他のメンバーの使用を見ることでバイラルループを作成
- 構文不要、自然なチャットインターフェース
- メッセージ、スレッドコンテキスト、チャネル名からリポジトリを分類

どのリポジトリで作業するかを決定する分類器を構築：
- 利用可能なリポジトリの記述を持つ高速モデル
- よく使用されるリポジトリのヒントを含める
- 曖昧なケースのための「不明」オプションを許可

**Webインターフェース**
コア機能：
- デスクトップとモバイルで動作
- エージェント作業のリアルタイムストリーミング
- サンドボックス内で実行されるホスト型VS Codeインスタンス
- 視覚的検証のためのストリームデスクトップビュー
- PRの変更前後のスクリーンショット

統計ページの表示内容：
- マージされたPRにつながったセッション（主要メトリクス）
- 時間経過による使用状況
- ライブの「プロンプト中の人数」カウント（直近5分間のプロンプト数）

**Chrome拡張機能**
非エンジニアユーザー向け：
- スクリーンショットツール付きのサイドバーチャットインターフェース
- 生画像の代わりにDOMとReact内部構造を抽出
- 精度を維持しながらトークン使用量を削減
- マネージドデバイスポリシーで配布（Chrome Web Storeをバイパス）

## 実践的ガイダンス

### フォローアップメッセージの処理

実行中に送信されたメッセージの処理方法を決定：
- **キューアプローチ**：現在のプロンプトが完了するまでメッセージを待機
- **挿入アプローチ**：メッセージを即座に処理

キューイングは管理が簡単で、エージェントの作業中にユーザーが次のステップについての考えを送信できます。必要に応じてエージェントを実行中に停止するメカニズムを構築してください。

### 重要なメトリクス

実際の価値を示すメトリクスを追跡：
- マージされたPRにつながったセッション（主要な成功メトリクス）
- セッション開始から最初のモデルレスポンスまでの時間
- PR承認率とリビジョン回数
- リポジトリ全体でのエージェントが書いたコードの割合

### 採用戦略

効果的な社内採用パターン：
- 可視性のためにパブリックスペース（Slackチャネル）で作業
- プロダクトにバイラルループを作らせる
- 既存ツールに対して使用を強制しない
- 仮想的な要件ではなく、人々のニーズに合わせて構築

## ガイドライン

1. 定期的なケイデンス（30分がデフォルトとして適切）で環境イメージを事前にビルド
2. ユーザーが送信した時ではなく、入力を始めた時にサンドボックスのウォーミングを開始
3. git同期完了前にファイル読み取りを許可；書き込みのみをブロック
4. エージェントフレームワークをサーバーファーストで構造化し、クライアントを薄いラッパーにする
5. クロスセッション干渉を防ぐためにセッションごとに状態を分離
6. コミットをアプリではなく、プロンプトを送信したユーザーに帰属させる
7. マージされたPRを主要な成功メトリクスとして追跡
8. 最初からマルチプレイヤーに対応して構築；適切な同期アーキテクチャがあればほぼ無料

## 統合

このスキルは、エージェント連携のためのmulti-agent-patternsと、エージェント-ツールインターフェースのためのtool-designを基盤としています。以下と関連します：

- multi-agent-patterns - 自己スポーンエージェントはスーパーバイザーパターンに従う
- tool-design - エージェントスポーンとステータス確認のためのツール構築
- context-optimization - 分散セッション間でのコンテキスト管理
- filesystem-context - セッション状態とアーティファクトのためのファイルシステム使用

## 参考資料

内部参考資料：
- [インフラストラクチャパターン](./references/infrastructure-patterns.md) - 詳細な実装パターン

このコレクション内の関連スキル：
- multi-agent-patterns - 自己スポーンエージェントの連携パターン
- tool-design - ホスト型環境向けのツール設計
- context-optimization - 分散システムにおけるコンテキスト管理

外部リソース：
- [Ramp](https://builders.ramp.com/post/why-we-built-our-background-agent) - 自社バックグラウンドエージェントを構築した理由
- [Modal Sandboxes](https://modal.com/docs/guide/sandbox) - クラウドサンドボックスインフラストラクチャ
- [Cloudflare Durable Objects](https://developers.cloudflare.com/durable-objects/) - セッションごとの状態管理
- [OpenCode](https://github.com/sst/opencode) - サーバーファーストエージェントフレームワーク

---

## スキルメタデータ

**作成日**: 2026-01-12
**最終更新日**: 2026-01-12
**著者**: Agent Skills for Context Engineering Contributors
**バージョン**: 1.0.0
