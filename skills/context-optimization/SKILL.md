---
name: context-optimization
description: このスキルは、ユーザーが「コンテキストを最適化」「トークンコストを削減」「コンテキスト効率を改善」「KVキャッシュ最適化を実装」「コンテキストを分割」と依頼した場合、またはコンテキスト制限、オブザベーションマスキング、コンテキストバジェット管理、実効コンテキスト容量の拡張に言及した場合に使用してください。
---

# コンテキスト最適化テクニック

コンテキスト最適化は、戦略的な圧縮、マスキング、キャッシング、パーティショニングを通じて、限られたコンテキストウィンドウの実効容量を拡張します。目的はコンテキストウィンドウを魔法のように増やすことではなく、利用可能な容量をより有効に活用することです。効果的な最適化により、より大きなモデルやより長いコンテキストを必要とせずに、実効コンテキスト容量を2倍から3倍に拡張できます。

## いつアクティブにするか

以下の場合にこのスキルをアクティブにしてください：
- コンテキスト制限がタスクの複雑さを制約している場合
- コスト削減のための最適化（トークンが少ない＝コストが低い）
- 長い会話のレイテンシ削減
- 長時間実行されるエージェントシステムの実装
- より大きなドキュメントや会話を処理する必要がある場合
- 本番環境でスケーラブルなシステムを構築する場合

## 主要コンセプト

コンテキスト最適化は、4つの主要戦略を通じて実効容量を拡張します：コンパクション（制限に近づいた際のコンテキスト要約）、オブザベーションマスキング（冗長な出力を参照に置換）、KVキャッシュ最適化（キャッシュされた計算の再利用）、コンテキストパーティショニング（分離されたコンテキスト間での作業分割）。

重要な洞察は、コンテキストの質が量よりも重要であるということです。最適化はノイズを削減しながらシグナルを保持します。何を保持し何を破棄するか、そしていつ各テクニックを適用するかの判断が鍵となります。

## 詳細トピック

### コンパクション戦略

**コンパクションとは**
コンパクションとは、制限に近づいた際にコンテキストの内容を要約し、その要約で新しいコンテキストウィンドウを再初期化する手法です。コンテキストウィンドウの内容を高忠実度で凝縮し、エージェントが最小限のパフォーマンス低下で継続できるようにします。

コンパクションは通常、コンテキスト最適化における最初の手段です。何を保持し何を破棄するかの判断が鍵となります。

**コンパクションの実装**
コンパクションは、圧縮可能なセクションを特定し、要点を捉えた要約を生成し、全文を要約に置き換えることで機能します。圧縮の優先順位は、ツール出力（要約で置換）、古いターン（初期の会話を要約）、取得したドキュメント（最新バージョンがあれば要約）の順で、システムプロンプトは決して圧縮しません。

**要約の生成**
効果的な要約は、メッセージタイプに応じて異なる要素を保持します：

ツール出力：主要な発見、メトリクス、結論を保持。冗長な生データを削除。

会話ターン：主要な決定、コミットメント、コンテキストの転換を保持。つなぎややり取りを削除。

取得したドキュメント：主要な事実と主張を保持。裏付け証拠や詳細説明を削除。

### オブザベーションマスキング

**オブザベーション問題**
ツール出力はエージェントの軌跡におけるトークン使用量の80%以上を占めることがあります。その多くは、既に役目を果たした冗長な出力です。エージェントがツール出力を使って意思決定を行った後、全出力を保持し続けることは、大量のコンテキストを消費しながら価値は逓減していきます。

オブザベーションマスキングは、冗長なツール出力をコンパクトな参照に置き換えます。情報は必要に応じてアクセス可能ですが、コンテキストを継続的に消費しません。

**マスキング戦略の選択**
すべてのオブザベーションを同等にマスクすべきではありません：

マスクしない：現在のタスクに重要なオブザベーション、直近のターンからのオブザベーション、アクティブな推論で使用中のオブザベーション。

マスクを検討：3ターン以上前のオブザベーション、要点を抽出可能な冗長な出力、役目を果たしたオブザベーション。

常にマスク：繰り返しの出力、定型のヘッダー/フッター、会話中に既に要約されている出力。

### KVキャッシュ最適化

**KVキャッシュの理解**
KVキャッシュは推論中に計算されたKeyおよびValueテンソルを保存し、シーケンス長に比例して線形に増加します。同一のプレフィックスを共有するリクエスト間でKVキャッシュをキャッシングすることで、再計算を回避します。

プレフィックスキャッシングは、ハッシュベースのブロックマッチングを使用して、同一のプレフィックスを持つリクエスト間でKVブロックを再利用します。これにより、システムプロンプトのような共通プレフィックスを持つリクエストのコストとレイテンシが劇的に削減されます。

**キャッシュ最適化パターン**
キャッシュヒットを最大化するためにコンテキスト要素を並び替えて最適化します。安定した要素を最初に配置し（システムプロンプト、ツール定義）、次に頻繁に再利用される要素、最後にユニークな要素を配置します。

キャッシュの安定性を最大化するようにプロンプトを設計します：タイムスタンプなどの動的コンテンツを避け、一貫したフォーマットを使用し、セッション間で構造を安定させます。

### コンテキストパーティショニング

**サブエージェントパーティショニング**
コンテキスト最適化の最も積極的な形態は、分離されたコンテキストを持つサブエージェント間で作業を分割することです。各サブエージェントは、他のサブタスクからの蓄積されたコンテキストを持たない、サブタスクに特化したクリーンなコンテキストで動作します。

このアプローチは関心の分離を実現します—詳細な検索コンテキストはサブエージェント内に隔離され、コーディネーターは統合と分析に集中します。

**結果の集約**
パーティションされたサブタスクの結果を集約するには、すべてのパーティションが完了したことを検証し、互換性のある結果をマージし、まだ大きすぎる場合は要約します。

### バジェット管理

**コンテキストバジェットの割り当て**
明示的なコンテキストバジェットを設計します。トークンをカテゴリに割り当てます：システムプロンプト、ツール定義、取得したドキュメント、メッセージ履歴、予約バッファ。バジェットに対する使用量を監視し、制限に近づいた際に最適化をトリガーします。

**トリガーベースの最適化**
最適化トリガーのシグナルを監視します：トークン使用率が80%超、劣化の指標、パフォーマンスの低下。コンテキスト構成に基づいて適切な最適化テクニックを適用します。

## 実践的なガイダンス

### 最適化の意思決定フレームワーク

最適化するタイミング：
- コンテキスト使用率が70%を超えた場合
- 会話が長くなるにつれてレスポンス品質が低下する場合
- 長いコンテキストによりコストが増加する場合
- 会話長に伴いレイテンシが増加する場合

適用すべきもの：
- ツール出力が支配的：オブザベーションマスキング
- 取得したドキュメントが支配的：要約またはパーティショニング
- メッセージ履歴が支配的：要約を伴うコンパクション
- 複数のコンポーネント：戦略を組み合わせる

### パフォーマンスに関する考慮事項

コンパクションは、品質低下5%未満で50〜70%のトークン削減を達成すべきです。マスキングは、マスクされたオブザベーションで60〜80%の削減を達成すべきです。キャッシュ最適化は、安定したワークロードで70%以上のヒット率を達成すべきです。

測定された効果に基づいて最適化戦略を監視し、反復的に改善してください。

## 例

**例1: コンパクショントリガー**
```python
if context_tokens / context_limit > 0.8:
    context = compact_context(context)
```

**例2: オブザベーションマスキング**
```python
if len(observation) > max_length:
    ref_id = store_observation(observation)
    return f"[Obs:{ref_id} elided. Key: {extract_key(observation)}]"
```

**例3: キャッシュフレンドリーな順序付け**
```python
# Stable content first
context = [system_prompt, tool_definitions]  # Cacheable
context += [reused_templates]  # Reusable
context += [unique_content]  # Unique
```

## ガイドライン

1. 最適化の前に測定する—現在の状態を把握する
2. 可能な場合はマスキングの前にコンパクションを適用する
3. 一貫したプロンプトでキャッシュの安定性を設計する
4. コンテキストが問題になる前にパーティショニングする
5. 最適化の効果を経時的に監視する
6. トークン節約と品質保持のバランスを取る
7. 本番スケールで最適化をテストする
8. エッジケースに対してグレースフルデグラデーションを実装する

## 統合

このスキルは context-fundamentals と context-degradation の上に構築されています。以下と連携します：

- multi-agent-patterns - 隔離としてのパーティショニング
- evaluation - 最適化効果の測定
- memory-systems - メモリへのコンテキストオフロード

## 参考資料

内部参考：
- [Optimization Techniques Reference](./references/optimization_techniques.md) - 詳細な技術リファレンス

このコレクション内の関連スキル：
- context-fundamentals - コンテキストの基礎
- context-degradation - 最適化のタイミングの理解
- evaluation - 最適化の測定

外部リソース：
- コンテキストウィンドウの制限に関する研究
- KVキャッシュ最適化テクニック
- 本番エンジニアリングガイド

---

## スキルメタデータ

**作成日**: 2025-12-20
**最終更新日**: 2025-12-20
**著者**: Agent Skills for Context Engineering Contributors
**バージョン**: 1.0.0
