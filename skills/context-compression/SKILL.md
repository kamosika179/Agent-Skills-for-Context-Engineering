---
name: context-compression
description: このスキルは、ユーザーが「コンテキストを圧縮する」「会話履歴を要約する」「コンパクションを実装する」「トークン使用を削減する」と求めた場合、またはコンテキスト圧縮、構造化サマリー、タスクあたりのトークン最適化、コンテキスト制限を超える長時間実行エージェントセッションについて言及する場合に使用します。
---

# コンテキスト圧縮戦略

エージェントセッションが数百万トークンの会話履歴を生成する場合、圧縮は必須となります。素朴なアプローチは、リクエストあたりのトークンを最小化する積極的な圧縮です。正しい最適化ターゲットは、タスクあたりのトークンです：タスクを完了するために消費される総トークン数であり、圧縮が重要な情報を失った場合の再取得コストを含みます。

## 有効化のタイミング

以下の場合にこのスキルを有効化してください：
- エージェントセッションがコンテキストウィンドウの制限を超える場合
- コードベースがコンテキストウィンドウを超える場合（5M以上のトークンのシステム）
- 会話要約戦略を設計する時
- エージェントが「変更したファイルを忘れる」ケースのデバッグ時
- 圧縮品質の評価フレームワークを構築する時

## コアコンセプト

コンテキスト圧縮は、トークンの節約と情報の損失をトレードオフします。3つのプロダクション対応アプローチが存在します：

1. **アンカードイテレーティブサマリゼーション**: セッションの意図、ファイル変更、決定、および次のステップの明示的なセクションを持つ構造化された永続的なサマリーを維持します。圧縮がトリガーされた時、新しく切り詰められたスパンのみを要約し、既存のサマリーとマージします。構造が、特定の情報タイプにセクションを割り当てることで保持を強制します。

2. **オペーク圧縮**: 再構築の忠実性に最適化された圧縮表現を生成します。最高の圧縮率（99%以上）を達成しますが、解釈可能性を犠牲にします。何が保持されたかを検証できません。

3. **リジェネレーティブフルサマリー**: 各圧縮時に詳細な構造化サマリーを生成します。読みやすい出力を生成しますが、インクリメンタルマージではなく完全な再生成のため、繰り返しの圧縮サイクルにわたって詳細を失う可能性があります。

重要な洞察：構造が保持を強制します。専用のセクションは、サマライザーが必ず埋めなければならないチェックリストとして機能し、サイレントな情報ドリフトを防ぎます。

## 詳細トピック

### タスクあたりのトークンが重要な理由

従来の圧縮メトリクスは、リクエストあたりのトークンをターゲットにしています。これは間違った最適化です。圧縮がファイルパスやエラーメッセージなどの重要な詳細を失うと、エージェントは情報を再取得し、アプローチを再探索し、コンテキストの回復にトークンを無駄にしなければなりません。

正しいメトリクスはタスクあたりのトークンです：タスクの開始から完了までに消費される総トークン数です。0.5%多くのトークンを節約しても20%多くの再取得を引き起こす圧縮戦略は、全体的にはより多くのコストがかかります。

### アーティファクトトレイルの問題

アーティファクトトレイルの整合性は、すべての圧縮メソッドで最も弱い次元であり、評価で5.0中2.2〜2.5のスコアです。明示的なファイルセクションを持つ構造化サマリゼーションでさえ、長いセッションにわたる完全なファイル追跡の維持に苦労します。

コーディングエージェントは以下を知る必要があります：
- どのファイルが作成されたか
- どのファイルが変更され、何が変わったか
- どのファイルが読み取られたが変更されなかったか
- 関数名、変数名、エラーメッセージ

この問題は、一般的な要約を超えた専門的な処理を必要とする可能性が高いです：別のアーティファクトインデックスや、エージェントスキャフォールディングにおける明示的なファイル状態追跡です。

### 構造化サマリーセクション

効果的な構造化サマリーには明示的なセクションが含まれます：

```markdown
## Session Intent
[What the user is trying to accomplish]

## Files Modified
- auth.controller.ts: Fixed JWT token generation
- config/redis.ts: Updated connection pooling
- tests/auth.test.ts: Added mock setup for new config

## Decisions Made
- Using Redis connection pool instead of per-request connections
- Retry logic with exponential backoff for transient failures

## Current State
- 14 tests passing, 2 failing
- Remaining: mock setup for session service tests

## Next Steps
1. Fix remaining test failures
2. Run full test suite
3. Update documentation
```

この構造は、各セクションが明示的に対処されなければならないため、ファイルパスや決定のサイレントな損失を防ぎます。

### 圧縮トリガー戦略

いつ圧縮をトリガーするかは、どのように圧縮するかと同じくらい重要です：

| 戦略 | トリガーポイント | トレードオフ |
|----------|---------------|-----------|
| 固定閾値 | コンテキスト利用率70〜80% | シンプルだが早すぎる圧縮の可能性 |
| スライディングウィンドウ | 最後のNターン＋サマリーを保持 | 予測可能なコンテキストサイズ |
| 重要度ベース | 低関連性セクションを先に圧縮 | 複雑だがシグナルを保持 |
| タスク境界 | 論理的なタスク完了時に圧縮 | クリーンなサマリーだが予測不可能なタイミング |

構造化サマリー付きのスライディングウィンドウアプローチは、ほとんどのコーディングエージェントのユースケースにおいて、予測可能性と品質の最良のバランスを提供します。

### プローブベースの評価

ROUGEやエンベディングの類似性などの従来のメトリクスは、機能的な圧縮品質を捕捉できません。サマリーは語彙の重複で高いスコアを獲得しながら、エージェントが必要とする1つのファイルパスを見逃す可能性があります。

プローブベースの評価は、圧縮後に質問することで機能的な品質を直接測定します：

| プローブタイプ | テスト対象 | 質問例 |
|------------|---------------|------------------|
| リコール | 事実の保持 | 「元のエラーメッセージは何でしたか？」 |
| アーティファクト | ファイル追跡 | 「どのファイルを変更しましたか？」 |
| 継続 | タスク計画 | 「次に何をすべきですか？」 |
| 決定 | 推論チェーン | 「Redisの問題について何を決定しましたか？」 |

圧縮が正しい情報を保持していれば、エージェントは正しく回答します。そうでなければ、推測またはハルシネーションします。

### 評価次元

6つの次元がコーディングエージェントの圧縮品質を捕捉します：

1. **正確性**: 技術的な詳細は正しいか？ファイルパス、関数名、エラーコード。
2. **コンテキスト認識**: レスポンスは現在の会話状態を反映しているか？
3. **アーティファクトトレイル**: エージェントはどのファイルが読み取られたか変更されたかを知っているか？
4. **完全性**: レスポンスは質問のすべての部分に対処しているか？
5. **継続性**: 情報の再取得なしに作業を継続できるか？
6. **指示への準拠**: レスポンスは述べられた制約を尊重しているか？

正確性は圧縮メソッド間で最大のバリエーションを示します（0.6ポイントの差）。アーティファクトトレイルは普遍的に弱いです（2.2〜2.5の範囲）。

## 実践ガイダンス

### 3フェーズ圧縮ワークフロー

コンテキストウィンドウを超える大規模なコードベースやエージェントシステムには、3つのフェーズを通じて圧縮を適用します：

1. **調査フェーズ**: アーキテクチャ図、ドキュメント、および主要なインターフェースから調査ドキュメントを作成します。探索をコンポーネントと依存関係の構造化された分析に圧縮します。出力：単一の調査ドキュメント。

2. **計画フェーズ**: 調査を関数シグネチャ、型定義、およびデータフローを含む実装仕様に変換します。5Mトークンのコードベースは約2,000語の仕様に圧縮されます。

3. **実装フェーズ**: 仕様に対して実行します。コンテキストは生のコードベース探索ではなく、仕様に集中し続けます。

### シードとしてのアーティファクト例の使用

手動の移行例やリファレンスPRが提供された場合、ターゲットパターンを理解するためのテンプレートとして使用します。この例は、静的解析では表面化できない制約を明らかにします：どの不変条件が保持されなければならないか、どのサービスが変更で壊れるか、そしてクリーンな移行がどのように見えるかです。

これは、エージェントが本質的な複雑さ（ビジネス要件）と偶発的な複雑さ（レガシーの回避策）を区別できない場合に特に重要です。アーティファクト例はその区別をエンコードします。

### アンカードイテレーティブサマリゼーションの実装

1. エージェントのニーズに合わせた明示的なサマリーセクションを定義する
2. 最初の圧縮トリガー時に、切り詰められた履歴をセクションに要約する
3. 後続の圧縮時には、新しく切り詰められたコンテンツのみを要約する
4. 再生成ではなく、既存のセクションに新しいサマリーをマージする
5. デバッグのために、どの情報がどの圧縮サイクルからのものかを追跡する

### 各アプローチの使用タイミング

**アンカードイテレーティブサマリゼーションを使用する場合：**
- セッションが長時間実行される場合（100メッセージ以上）
- ファイル追跡が重要な場合（コーディング、デバッグ）
- 何が保持されたかを検証する必要がある場合

**オペーク圧縮を使用する場合：**
- 最大のトークン節約が必要な場合
- セッションが比較的短い場合
- 再取得コストが低い場合

**リジェネレーティブサマリーを使用する場合：**
- サマリーの解釈可能性が重要な場合
- セッションに明確なフェーズ境界がある場合
- 各圧縮時の完全なコンテキストレビューが許容される場合

### 圧縮率の考慮事項

| メソッド | 圧縮率 | 品質スコア | トレードオフ |
|--------|-------------------|---------------|-----------|
| アンカードイテレーティブ | 98.6% | 3.70 | 最高品質、やや低い圧縮率 |
| リジェネレーティブ | 98.7% | 3.44 | 良い品質、中程度の圧縮率 |
| オペーク | 99.3% | 3.35 | 最高の圧縮率、品質の損失 |

構造化サマリゼーションによって保持される追加0.7%のトークンは、0.35の品質ポイントを獲得します。再取得コストが重要なタスクでは、このトレードオフは構造化アプローチに有利です。

## 例

**例1：デバッグセッションの圧縮**

元のコンテキスト（89,000トークン、178メッセージ）：
- /api/auth/loginエンドポイントでの401エラー
- authコントローラー、ミドルウェア、セッションストアを調査
- 古くなったRedis接続を発見
- 接続プーリングを修正、リトライロジックを追加
- 14テスト合格、2テスト不合格

圧縮後の構造化サマリー：

```markdown
## Session Intent
Debug 401 Unauthorized error on /api/auth/login despite valid credentials.

## Root Cause
Stale Redis connection in session store. JWT generated correctly but session could not be persisted.

## Files Modified
- auth.controller.ts: No changes (read only)
- middleware/cors.ts: No changes (examined)
- config/redis.ts: Fixed connection pooling configuration
- services/session.service.ts: Added retry logic for transient failures
- tests/auth.test.ts: Updated mock setup

## Test Status
14 passing, 2 failing (mock setup issues)

## Next Steps
1. Fix remaining test failures (mock session service)
2. Run full test suite
3. Deploy to staging
```

**例2：プローブレスポンスの品質**

圧縮後、「元のエラーは何でしたか？」と質問した場合：

良いレスポンス（構造化サマリゼーション）：
> 「元のエラーは/api/auth/loginエンドポイントからの401 Unauthorizedレスポンスでした。有効な資格情報にもかかわらず、ユーザーはこのエラーを受け取りました。根本原因はセッションストアの古くなったRedis接続でした。」

悪いレスポンス（積極的な圧縮）：
> 「認証の問題をデバッグしていました。ログインが失敗していました。いくつかの設定の問題を修正しました。」

構造化レスポンスはエンドポイント、エラーコード、および根本原因を保持しています。積極的なレスポンスはすべての技術的な詳細を失っています。

## ガイドライン

1. リクエストあたりのトークンではなく、タスクあたりのトークンを最適化する
2. ファイル追跡のための明示的なセクションを持つ構造化サマリーを使用する
3. コンテキスト利用率70〜80%で圧縮をトリガーする
4. 完全な再生成ではなくインクリメンタルマージを実装する
5. プローブベースの評価で圧縮品質をテストする
6. ファイル追跡が重要な場合はアーティファクトトレイルを別途追跡する
7. より良い品質保持のためにやや低い圧縮率を受け入れる
8. 圧縮品質のシグナルとして再取得の頻度を監視する

## 統合

このスキルはコレクション内のいくつかの他のスキルに接続します：

- context-degradation - 圧縮は劣化に対する緩和戦略である
- context-optimization - 圧縮は多くの最適化技術の1つである
- evaluation - プローブベースの評価は圧縮テストに適用される
- memory-systems - 圧縮はスクラッチパッドとサマリーメモリパターンに関連する

## 参考文献

内部参考：
- [Evaluation Framework Reference](./references/evaluation-framework.md) - 詳細なプローブタイプとスコアリングルーブリック

このコレクションの関連スキル：
- context-degradation - 圧縮が防ぐものの理解
- context-optimization - より広い最適化戦略
- evaluation - 評価フレームワークの構築

外部リソース：
- Factory Research: Evaluating Context Compression for AI Agents (December 2025)
- Research on LLM-as-judge evaluation methodology (Zheng et al., 2023)
- Netflix Engineering: "The Infinite Software Crisis" - Three-phase workflow and context compression at scale (AI Summit 2025)

---

## スキルメタデータ

**作成日**: 2025-12-22
**最終更新日**: 2025-12-26
**著者**: Agent Skills for Context Engineering Contributors
**バージョン**: 1.1.0

