---
name: memory-systems
description: >
  エージェントメモリシステムの実装をガイドし、本番フレームワーク
  （Mem0、Zep/Graphiti、Letta、LangMem）を比較し、クロスセッションの
  知識保持のための永続化アーキテクチャを設計します。ユーザーが「エージェント
  メモリを実装」「セッション間で状態を永続化」「エージェント用のナレッジグラフを
  構築」「エンティティを経時的に追跡」「長期メモリを追加」「メモリフレームワークを
  選択」と依頼した場合、またはテンポラルナレッジグラフ、ベクトルストア、
  エンティティメモリ、メモリベンチマーク（LoCoMo、LongMemEval）に
  言及した場合に使用してください。
---

# メモリシステム設計

メモリは、エージェントがセッション間で継続性を維持し、蓄積された知識に基づいて推論できるようにする永続化レイヤーを提供します。単純なエージェントはメモリをコンテキストのみに依存し、セッション終了時にすべての状態を失います。高度なエージェントは、即時のコンテキストニーズと長期的な知識保持のバランスをとる階層型メモリアーキテクチャを実装します。ベクトルストアからナレッジグラフ、さらにテンポラルナレッジグラフへの進化は、検索と推論を改善するための構造化メモリへの投資の増加を表しています。

## いつアクティブにするか

以下の場合にこのスキルをアクティブにしてください：
- セッション間で知識を永続化する必要があるエージェントを構築する場合
- メモリフレームワーク（Mem0、Zep/Graphiti、Letta、LangMem）の選択
- 会話間でエンティティの一貫性を維持する必要がある場合
- 蓄積された知識に基づく推論の実装
- 本番環境でスケールするメモリアーキテクチャの設計
- ベンチマーク（LoCoMo、LongMemEval、DMR）に対するメモリシステムの評価

## 主要コンセプト

メモリは、揮発性のコンテキストウィンドウから永続ストレージまでのスペクトラムにまたがります。ベンチマークからの重要な洞察：**ツールの複雑さよりも信頼性の高い検索が重要** — Lettaのファイルシステムエージェントは基本的なファイル操作を使用してLoCoMoで74%を記録し、Mem0の専門ツールの68.5%を上回りました。シンプルに始め、検索品質が要求する場合にのみ構造（グラフ、テンポラルバリディティ）を追加してください。

## 詳細トピック

### 本番フレームワークの全体像

| フレームワーク | アーキテクチャ | 最適な用途 | トレードオフ |
|-----------|-------------|----------|-----------|
| **Mem0** | ベクトルストア + グラフメモリ、プラガブルバックエンド | マルチテナントシステム、幅広い統合 | マルチエージェントへの特化度が低い |
| **Zep/Graphiti** | テンポラルナレッジグラフ、バイテンポラルモデル | リレーションシップモデリング + テンポラル推論を必要とするエンタープライズ | 高度な機能がクラウドにロック |
| **Letta** | 階層型ストレージ（インコンテキスト/コア/アーカイブ）を持つ自己編集メモリ | 完全なエージェントイントロスペクション、ステートフルサービス | 単純なユースケースには複雑 |
| **LangMem** | LangGraphワークフロー用のメモリツール | 既にLangGraphを使用しているチーム | LangGraphに密結合 |
| **ファイルシステム** | 命名規則を持つプレーンファイル | 単純なエージェント、プロトタイピング | セマンティック検索なし、リレーションシップなし |

Zep の Graphiti エンジンは、3層のナレッジグラフ（エピソード、セマンティックエンティティ、コミュニティサブグラフ）を構築し、イベントの発生時期と取り込み時期の両方を追跡するバイテンポラルモデルを持ちます。Mem0はマネージドインフラストラクチャにより本番環境への最速パスを提供します。Lettaはそのエージェント開発環境を通じて最も深いエージェント制御を提供します。

**ベンチマークパフォーマンス比較**

| システム | DMR精度 | LoCoMo | レイテンシ |
|--------|-------------|--------|---------|
| Zep (Temporal KG) | 94.8% | — | 2.58秒 |
| Letta (filesystem) | — | 74.0% | — |
| Mem0 | — | 68.5% | — |
| MemGPT | 93.4% | — | 可変 |
| GraphRAG | 約75-85% | — | 可変 |
| Vector RAGベースライン | 約60-70% | — | 高速 |

ZepはLongMemEvalで最大18.5%の精度向上を達成し、レイテンシを90%削減します。重要な洞察：Lettaのファイルシステムベースのエージェントは基本的なファイル操作を使用してLoCoMoで74%を達成し、専門メモリツールを上回りました — ツールの複雑さよりも信頼性の高い検索が重要です。

### メモリレイヤー（判断ポイント）

| レイヤー | 永続性 | 実装 | 使用場面 |
|-------|------------|----------------|-------------|
| **ワーキング** | コンテキストウィンドウのみ | システムプロンプト内のスクラッチパッド | 常に — アテンション優先位置で最適化 |
| **短期** | セッションスコープ | ファイルシステム、インメモリキャッシュ | 中間ツール結果、会話状態 |
| **長期** | クロスセッション | キーバリューストア → グラフDB | ユーザー設定、ドメイン知識、エンティティレジストリ |
| **エンティティ** | クロスセッション | エンティティレジストリ + プロパティ | アイデンティティの維持（「山田太郎」＝会話を跨いで同一人物） |
| **テンポラルKG** | クロスセッション + 履歴 | バリディティインターバルを持つグラフ | 時間とともに変化する事実、タイムトラベルクエリ、コンテキスト衝突の防止 |

### 検索戦略

| 戦略 | 使用場面 | 制限 |
|----------|----------|------------|
| **セマンティック**（埋め込み類似度） | 直接的な事実クエリ | マルチホップ推論で劣化 |
| **エンティティベース**（グラフ探索） | 「Xについて全部教えて」 | グラフ構造が必要 |
| **テンポラル**（バリディティフィルター） | 時間とともに変化する事実 | バリディティメタデータが必要 |
| **ハイブリッド**（セマンティック + キーワード + グラフ） | 全体的に最高精度 | 最もインフラが必要 |

Zepのハイブリッドアプローチは、関連するサブグラフのみを取得することで90%のレイテンシ削減（2.58秒 vs 28.9秒）を達成します。

### メモリの統合

無制限な増加を防ぐために定期的に統合します。**無効化するが破棄しない** — テンポラルクエリにおいて履歴の保持が重要です。メモリ数のしきい値、検索品質の劣化、またはスケジュールされた間隔でトリガーします。動作する統合コードについては[実装リファレンス](./references/implementation.md)を参照してください。

## 実践的なガイダンス

### メモリアーキテクチャの選択

**シンプルに始め、検索が失敗した場合にのみ複雑さを追加する。** ほとんどのエージェントは初日からテンポラルナレッジグラフを必要としません。

1. **プロトタイプ**：ファイルシステムメモリ。タイムスタンプ付きの構造化JSONとして事実を保存。エージェントの動作を検証するのに十分。
2. **スケール**：セマンティック検索とマルチテナント分離が必要な場合にMem0またはメタデータ付きベクトルストアに移行。
3. **複雑な推論**：リレーションシップの探索、テンポラルバリディティ、クロスセッション統合が必要な場合にZep/Graphitiを追加。
4. **完全な制御**：深いイントロスペクションを伴うエージェントのメモリ自己管理が必要な場合にLettaを使用。

### コンテキストとの統合

メモリは有用であるためにコンテキストシステムと統合する必要があります。ジャストインタイムメモリローディングを使用して、必要な時に関連するメモリを取得します。戦略的インジェクションを使用して、アテンション優先位置（コンテキストの先頭/末尾）にメモリを配置します。

### エラーリカバリ

- **空の検索結果**：より広い検索にフォールバック（エンティティフィルターの削除、時間範囲の拡大）。それでも空の場合、ユーザーに明確化を促す。
- **古い結果**：`valid_until` タイムスタンプを確認。ほとんどの結果が期限切れの場合、リトライ前に統合をトリガー。
- **矛盾する事実**：最新の `valid_from` を持つ事実を優先。信頼度が低い場合、矛盾をユーザーに提示。
- **ストレージ障害**：書き込みをリトライ用にキューに入れる。メモリ書き込みでエージェントの応答をブロックしない。

### アンチパターン

- **すべてをコンテキストに詰め込む**：長い入力は高コストでパフォーマンスを低下させる。ジャストインタイム検索を使用する。
- **テンポラルバリディティを無視する**：事実は古くなる。バリディティ追跡なしでは、古い情報がコンテキストを汚染する。
- **早期の過剰設計**：ファイルシステムエージェントが複雑なメモリツールを上回ることがある。シンプルなアプローチが失敗した場合に高度化を追加する。
- **統合戦略がない**：無制限なメモリ増加は検索品質を経時的に劣化させる。

## 例

**例1: Mem0 統合**
```python
from mem0 import Memory

m = Memory()
m.add("User prefers dark mode and Python 3.12", user_id="alice")
m.add("User switched to light mode", user_id="alice")

# Retrieves current preference (light mode), not outdated one
results = m.search("What theme does the user prefer?", user_id="alice")
```

**例2: テンポラルクエリ**
```python
# Track entity with validity periods
graph.create_temporal_relationship(
    source_id=user_node,
    rel_type="LIVES_AT",
    target_id=address_node,
    valid_from=datetime(2024, 1, 15),
    valid_until=datetime(2024, 9, 1),  # moved out
)

# Query: Where did user live on March 1, 2024?
results = graph.query_at_time(
    {"type": "LIVES_AT", "source_label": "User"},
    query_time=datetime(2024, 3, 1)
)
```

## ガイドライン

1. ファイルシステムメモリから始め、検索品質が要求する場合にのみ複雑さを追加する
2. 時間とともに変化しうる事実にはテンポラルバリディティを追跡する
3. 最高精度のためにハイブリッド検索（セマンティック + キーワード + グラフ）を使用する
4. メモリを定期的に統合する — 無効化するが破棄しない
5. 検索失敗に備えて設計する：メモリ検索が何も返さない場合のフォールバックを常に用意する
6. 永続メモリのプライバシーへの影響を考慮する（保持ポリシー、削除権）
7. 変更前後にLoCoMoまたはLongMemEvalに対してメモリシステムをベンチマークする
8. 本番環境でのメモリ増加と検索レイテンシを監視する

## 統合

このスキルは context-fundamentals の上に構築されています。以下と連携します：

- multi-agent-patterns - エージェント間の共有メモリ
- context-optimization - メモリベースのコンテキストローディング
- evaluation - メモリ品質の評価

## 参考資料

内部参考：
- [Implementation Reference](./references/implementation.md) - 詳細な実装パターン

このコレクション内の関連スキル：
- context-fundamentals - コンテキストの基礎
- multi-agent-patterns - クロスエージェントメモリ

外部リソース：
- Zep テンポラルナレッジグラフ論文 (arXiv:2501.13956)
- Mem0 本番アーキテクチャ論文 (arXiv:2504.19413)
- LoCoMo ベンチマーク (Snap Research)
- MemBench 評価フレームワーク (ACL 2025)
- Graphiti オープンソーステンポラルKGエンジン (github.com/getzep/graphiti)

---

## スキルメタデータ

**作成日**: 2025-12-20
**最終更新日**: 2026-02-12
**著者**: Agent Skills for Context Engineering Contributors
**バージョン**: 2.0.0
