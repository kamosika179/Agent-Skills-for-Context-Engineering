---
name: multi-agent-patterns
description: このスキルは、ユーザーが「マルチエージェントシステムを設計」「スーパーバイザーパターンを実装」「スウォームアーキテクチャを作成」「複数のエージェントを調整」と依頼した場合、またはマルチエージェントパターン、コンテキスト隔離、エージェントハンドオフ、サブエージェント、並列エージェント実行に言及した場合に使用してください。
---

# マルチエージェントアーキテクチャパターン

マルチエージェントアーキテクチャは、それぞれ独自のコンテキストウィンドウを持つ複数の言語モデルインスタンス間で作業を分散させます。適切に設計された場合、この分散は単一エージェントの限界を超える能力を実現します。設計が不十分な場合、調整のオーバーヘッドが利点を打ち消します。重要な洞察は、サブエージェントは主に役割分担を擬人化するためではなく、コンテキストを隔離するために存在するということです。

## いつアクティブにするか

以下の場合にこのスキルをアクティブにしてください：
- 単一エージェントのコンテキスト制限がタスクの複雑さを制約している場合
- タスクが自然に並列サブタスクに分解できる場合
- 異なるサブタスクが異なるツールセットやシステムプロンプトを必要とする場合
- 複数のドメインを同時に処理するシステムを構築する場合
- 単一コンテキストの限界を超えてエージェント能力を拡張する場合
- 複数の専門コンポーネントを持つ本番エージェントシステムを設計する場合

## 主要コンセプト

マルチエージェントシステムは、分散を通じて単一エージェントのコンテキスト制限に対処します。3つの主要パターンが存在します：集中制御のためのスーパーバイザー/オーケストレーター、柔軟なハンドオフのためのピアツーピア/スウォーム、階層的抽象化のためのヒエラルキカルパターン。重要な設計原則はコンテキスト隔離です—サブエージェントは組織的な役割をシミュレートするためではなく、主にコンテキストを分割するために存在します。

効果的なマルチエージェントシステムには、明示的な調整プロトコル、迎合を避けるコンセンサスメカニズム、ボトルネック、発散、エラー伝播を含む障害モードへの注意が必要です。

## 詳細トピック

### マルチエージェントアーキテクチャの理由

**コンテキストのボトルネック**
単一エージェントは、推論能力、コンテキスト管理、ツール調整において本質的な上限に直面します。タスクが複雑になるにつれ、コンテキストウィンドウは蓄積された履歴、取得したドキュメント、ツール出力で満たされます。パフォーマンスは予測可能なパターンに従って低下します：中間喪失効果、アテンション不足、コンテキスト汚染。

マルチエージェントアーキテクチャは、複数のコンテキストウィンドウ間で作業を分割することでこれらの制限に対処します。各エージェントは自身のサブタスクに特化したクリーンなコンテキストで動作します。結果は調整レイヤーで集約され、単一のコンテキストが全負荷を負担することはありません。

**トークンエコノミクスの現実**
マルチエージェントシステムは、単一エージェントアプローチよりも大幅に多くのトークンを消費します。本番データは以下を示しています：

| アーキテクチャ | トークン倍率 | ユースケース |
|--------------|------------------|----------|
| 単一エージェントチャット | 1×ベースライン | 単純なクエリ |
| ツール付き単一エージェント | 約4×ベースライン | ツール使用タスク |
| マルチエージェントシステム | 約15×ベースライン | 複雑なリサーチ/調整 |

BrowseComp評価に関する研究では、パフォーマンスの分散の95%を3つの要因が説明することが判明しました：トークン使用量（分散の80%）、ツール呼び出し回数、モデルの選択。これは、並列推論のための容量を追加するために、別々のコンテキストウィンドウを持つエージェント間で作業を分散させるマルチエージェントアプローチを検証しています。

重要なことに、より優れたモデルへのアップグレードは、トークンバジェットの倍増よりも大きなパフォーマンス向上をもたらすことが多いです。Claude Sonnet 4.5は以前のSonnetバージョンでトークンを倍増させるよりも大きな向上を示しました。GPT-5.2の思考モードも同様に、単純なトークン増加を上回ります。これは、モデル選択とマルチエージェントアーキテクチャが相補的な戦略であることを示唆しています。

**並列化の論拠**
多くのタスクには、単一エージェントが順番に実行しなければならない並列化可能なサブタスクが含まれています。リサーチタスクでは、複数の独立したソースの検索、異なるドキュメントの分析、競合するアプローチの比較が必要になることがあります。単一エージェントはこれらを順番に処理し、各ステップでコンテキストを蓄積します。

マルチエージェントアーキテクチャは、各サブタスクを新しいコンテキストを持つ専用エージェントに割り当てます。すべてのエージェントが同時に作業し、結果をコーディネーターに返します。実時間の合計は、すべてのサブタスクの合計ではなく、最長のサブタスクの所要時間に近づきます。

**専門化の論拠**
異なるタスクは異なるエージェント構成から恩恵を受けます：異なるシステムプロンプト、異なるツールセット、異なるコンテキスト構造。汎用エージェントはすべての可能な構成をコンテキストに含める必要があります。専門化されたエージェントは必要なもののみを含みます。

マルチエージェントアーキテクチャは、組み合わせ爆発なしに専門化を可能にします。コーディネーターが専門エージェントにルーティングし、各エージェントはそのドメインに最適化された軽量なコンテキストで動作します。

### アーキテクチャパターン

**パターン1: スーパーバイザー/オーケストレーター**
スーパーバイザーパターンは、中央のエージェントを制御に配置し、スペシャリストに委任して結果を統合します。スーパーバイザーはグローバルな状態と軌跡を維持し、ユーザーの目標をサブタスクに分解し、適切なワーカーにルーティングします。

```
User Query -> Supervisor -> [Specialist, Specialist, Specialist] -> Aggregation -> Final Output
```

使用場面：明確な分解が可能な複雑なタスク、ドメイン横断の調整を必要とするタスク、人間による監視が重要なタスク。

利点：ワークフローの厳密な制御、ヒューマンインザループ介入の実装が容易、事前定義された計画への準拠を保証。

欠点：スーパーバイザーのコンテキストがボトルネックになる、スーパーバイザーの障害がすべてのワーカーに波及、スーパーバイザーがサブエージェントの応答を不正確に言い換える「伝言ゲーム」問題。

**伝言ゲーム問題と解決策**
LangGraphのベンチマークでは、スーパーバイザーアーキテクチャがスーパーバイザーがサブエージェントの応答を不正確に言い換える「伝言ゲーム」問題により、最適化バージョンよりも当初50%パフォーマンスが低いことが判明しました。

解決策：サブエージェントが応答をユーザーに直接渡せる `forward_message` ツールを実装します：

```python
def forward_message(message: str, to_user: bool = True):
    """
    Forward sub-agent response directly to user without supervisor synthesis.
    
    Use when:
    - Sub-agent response is final and complete
    - Supervisor synthesis would lose important details
    - Response format must be preserved exactly
    """
    if to_user:
        return {"type": "direct_response", "content": message}
    return {"type": "supervisor_input", "content": message}
```

このパターンにより、サブエージェントがユーザーに直接応答し翻訳エラーを排除するため、スウォームアーキテクチャがスーパーバイザーをわずかに上回ります。

実装上の注意：適切な場合に、サブエージェントがスーパーバイザーの統合を経ずにユーザーに直接応答を渡せるダイレクトパススルーメカニズムを実装してください。

**パターン2: ピアツーピア/スウォーム**
ピアツーピアパターンは中央制御を排除し、事前定義されたプロトコルに基づいてエージェントが直接通信できるようにします。任意のエージェントが明示的なハンドオフメカニズムを通じて他のエージェントに制御を移すことができます。

```python
def transfer_to_agent_b():
    return agent_b  # Handoff via function return

agent_a = Agent(
    name="Agent A",
    functions=[transfer_to_agent_b]
)
```

使用場面：柔軟な探索を必要とするタスク、厳密な計画が逆効果となるタスク、事前分解を拒む創発的な要件を持つタスク。

利点：単一障害点がない、幅優先探索に効果的にスケール、創発的な問題解決行動を可能にする。

欠点：エージェント数の増加に伴い調整の複雑さが増大、中央状態管理者なしでの発散リスク、堅牢な収束制約が必要。

実装上の注意：状態渡しを伴う明示的なハンドオフプロトコルを定義してください。エージェントが受信エージェントにコンテキストのニーズを伝達できるようにしてください。

**パターン3: ヒエラルキカル**
ヒエラルキカル構造は、エージェントを抽象化のレイヤーに整理します：戦略レイヤー、計画レイヤー、実行レイヤー。戦略レイヤーのエージェントは目標と制約を定義し、計画レイヤーのエージェントは目標を実行可能な計画に分解し、実行レイヤーのエージェントはアトミックなタスクを実行します。

```
Strategy Layer (Goal Definition) -> Planning Layer (Task Decomposition) -> Execution Layer (Atomic Tasks)
```

使用場面：明確な階層構造を持つ大規模プロジェクト、管理レイヤーを持つエンタープライズワークフロー、高レベルの計画と詳細な実行の両方を必要とするタスク。

利点：組織構造を反映、明確な関心の分離、異なるレベルで異なるコンテキスト構造を可能にする。

欠点：レイヤー間の調整オーバーヘッド、戦略と実行間の不整合の可能性、複雑なエラー伝播。

### 設計原則としてのコンテキスト隔離

マルチエージェントアーキテクチャの主な目的はコンテキスト隔離です。各サブエージェントは、他のサブタスクからの蓄積されたコンテキストを持たない、サブタスクに特化したクリーンなコンテキストウィンドウで動作します。

**隔離メカニズム**
フルコンテキスト委任：サブエージェントが完全な理解を必要とする複雑なタスクでは、プランナーが全コンテキストを共有します。サブエージェントは独自のツールと指示を持ちますが、意思決定のためにフルコンテキストを受け取ります。

指示渡し：単純で明確に定義されたサブタスクでは、プランナーが関数呼び出しを介して指示を作成します。サブエージェントは特定のタスクに必要な指示のみを受け取ります。

ファイルシステムメモリ：共有状態を必要とする複雑なタスクでは、エージェントが永続ストレージの読み書きを行います。ファイルシステムが調整メカニズムとして機能し、共有状態渡しによるコンテキスト膨張を回避します。

**隔離のトレードオフ**
フルコンテキスト委任は最大の能力を提供しますが、サブエージェントの目的を無効にします。指示渡しは隔離を維持しますが、サブエージェントの柔軟性を制限します。ファイルシステムメモリはコンテキスト渡しなしで共有状態を可能にしますが、レイテンシと一貫性の課題を導入します。

適切な選択は、タスクの複雑さ、調整のニーズ、許容可能なレイテンシに依存します。

### コンセンサスと調整

**投票問題**
単純な多数決は、弱いモデルからのハルシネーションを強いモデルからの推論と同等に扱います。介入なしでは、マルチエージェントの議論は合意への固有のバイアスにより、誤った前提に基づくコンセンサスに退化します。

**重み付き投票**
信頼度や専門性に基づいてエージェントの投票に重み付けします。信頼度やドメイン専門性が高いエージェントは最終決定においてより大きな重みを持ちます。

**ディベートプロトコル**
ディベートプロトコルは、エージェントが複数ラウンドにわたって互いの出力を批評することを要求します。敵対的批評は、複雑な推論において協調的コンセンサスよりも高い精度をもたらすことが多いです。

**トリガーベースの介入**
特定の行動マーカーについてマルチエージェントのインタラクションを監視します。停滞トリガーは議論が進展しない場合にアクティブになります。迎合トリガーは、エージェントが独自の推論なしに互いの回答を模倣することを検出します。

### フレームワークに関する考慮事項

異なるフレームワークがこれらのパターンを異なる哲学で実装しています。LangGraphは明示的なノードとエッジを持つグラフベースのステートマシンを使用します。AutoGenはGroupChatを使った会話/イベント駆動パターンを使用します。CrewAIは階層的なクルー構造を持つロールベースのプロセスフローを使用します。

## 実践的なガイダンス

### 障害モードと軽減策

**障害：スーパーバイザーのボトルネック**
スーパーバイザーがすべてのワーカーからのコンテキストを蓄積し、飽和と劣化の影響を受けやすくなります。

軽減策：ワーカーが凝縮された要約のみを返すように出力スキーマ制約を実装します。チェックポイントを使用して、完全な履歴を保持せずにスーパーバイザーの状態を永続化します。

**障害：調整オーバーヘッド**
エージェント間通信がトークンを消費し、レイテンシを導入します。複雑な調整は並列化の利点を打ち消す可能性があります。

軽減策：明確なハンドオフプロトコルを通じて通信を最小化します。可能な場合は結果をバッチ処理します。非同期通信パターンを使用します。

**障害：発散**
中央の調整なしに異なる目標を追求するエージェントは、意図した目的から逸脱する可能性があります。

軽減策：各エージェントに明確な目標境界を定義します。共有目標に向けた進捗を検証する収束チェックを実装します。エージェント実行にTime-to-Live制限を設定します。

**障害：エラー伝播**
あるエージェントの出力のエラーが、その出力を消費する下流のエージェントに伝播します。

軽減策：消費者に渡す前にエージェントの出力を検証します。サーキットブレーカー付きのリトライロジックを実装します。可能な場合はべき等操作を使用します。

## 例

**例1: リサーチチームアーキテクチャ**
```text
Supervisor
├── Researcher (web search, document retrieval)
├── Analyzer (data analysis, statistics)
├── Fact-checker (verification, validation)
└── Writer (report generation, formatting)
```

**例2: ハンドオフプロトコル**
```python
def handle_customer_request(request):
    if request.type == "billing":
        return transfer_to(billing_agent)
    elif request.type == "technical":
        return transfer_to(technical_agent)
    elif request.type == "sales":
        return transfer_to(sales_agent)
    else:
        return handle_general(request)
```

## ガイドライン

1. マルチエージェントシステムの主要な利点としてコンテキスト隔離を設計する
2. 組織のメタファーではなく、調整ニーズに基づいてアーキテクチャパターンを選択する
3. 状態渡しを伴う明示的なハンドオフプロトコルを実装する
4. コンセンサスには重み付き投票またはディベートプロトコルを使用する
5. スーパーバイザーのボトルネックを監視し、チェックポイントを実装する
6. エージェント間で渡す前に出力を検証する
7. 無限ループを防ぐためにTime-to-Live制限を設定する
8. 障害シナリオを明示的にテストする

## 統合

このスキルは context-fundamentals と context-degradation の上に構築されています。以下と連携します：

- memory-systems - エージェント間の共有状態管理
- tool-design - エージェントごとのツール専門化
- context-optimization - コンテキストパーティショニング戦略

## 参考資料

内部参考：
- [Frameworks Reference](./references/frameworks.md) - 詳細なフレームワーク実装パターン

このコレクション内の関連スキル：
- context-fundamentals - コンテキストの基礎
- memory-systems - クロスエージェントメモリ
- context-optimization - パーティショニング戦略

外部リソース：
- [LangGraph Documentation](https://langchain-ai.github.io/langgraph/) - マルチエージェントパターンと状態管理
- [AutoGen Framework](https://microsoft.github.io/autogen/) - GroupChatと会話パターン
- [CrewAI Documentation](https://docs.crewai.com/) - 階層的エージェントプロセス
- [Research on Multi-Agent Coordination](https://arxiv.org/abs/2308.00352) - マルチエージェントシステムの調査

---

## スキルメタデータ

**作成日**: 2025-12-20
**最終更新日**: 2025-12-20
**著者**: Agent Skills for Context Engineering Contributors
**バージョン**: 1.0.0
