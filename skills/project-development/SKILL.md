---
name: project-development
description: このスキルは、ユーザーが「LLMプロジェクトを開始する」「バッチパイプラインを設計する」「タスク-モデル適合性を評価する」「エージェントプロジェクトを構造化する」と依頼した場合、またはパイプラインアーキテクチャ、エージェント支援開発、コスト見積もり、LLMと従来のアプローチの選択に言及した場合に使用してください。
---

# プロジェクト開発方法論

このスキルは、LLM処理に適したタスクの特定、効果的なプロジェクトアーキテクチャの設計、エージェント支援開発を使用した迅速な反復の原則をカバーします。この方法論は、バッチ処理パイプライン、マルチエージェントリサーチシステム、インタラクティブなエージェントアプリケーションのいずれを構築する場合にも適用されます。

## アクティベーション条件

以下の場合にこのスキルをアクティベートしてください：
- LLM処理の恩恵を受ける可能性のある新しいプロジェクトを開始する場合
- タスクがエージェントに適しているか従来のコードに適しているかを評価する場合
- LLMを活用したアプリケーションのアーキテクチャを設計する場合
- 構造化出力を持つバッチ処理パイプラインを計画する場合
- シングルエージェントとマルチエージェントのアプローチを選択する場合
- LLMを多用するプロジェクトのコストとタイムラインを見積もる場合

## コアコンセプト

### タスク-モデル適合性の認識

すべての問題がLLM処理の恩恵を受けるわけではありません。プロジェクトの最初のステップは、タスクの特性がLLMの強みと一致しているかを評価することです。この評価はコードを書く前に行うべきです。

**LLMに適したタスクの特性：**

| 特性 | 適している理由 |
|------|--------------|
| ソース間の統合 | LLMは複数の入力からの情報を組み合わせることに優れている |
| ルーブリック付きの主観的判断 | LLMは基準に基づく採点、評価、分類を処理できる |
| 自然言語出力 | 目標が構造化データではなく人間が読めるテキストの場合 |
| エラー耐性 | 個々の失敗がシステム全体を壊さない |
| バッチ処理 | アイテム間で会話状態が不要 |
| 学習データにドメイン知識がある | モデルが既に関連するコンテキストを持っている |

**LLMに不向きなタスクの特性：**

| 特性 | 失敗する理由 |
|------|------------|
| 精密な計算 | 数学、カウント、正確なアルゴリズムは信頼性が低い |
| リアルタイム要件 | LLMのレイテンシはサブ秒の応答には高すぎる |
| 完全な正確性の要件 | ハルシネーションのリスクにより100%の正確性は不可能 |
| プロプライエタリデータ依存 | モデルに必要なコンテキストがない |
| 逐次的な依存関係 | 各ステップが前の結果に大きく依存する |
| 決定論的出力の要件 | 同じ入力が同一の出力を生成する必要がある |

評価は手動プロトタイピングを通じて行うべきです：代表的な例を1つ取り、自動化を構築する前にターゲットモデルで直接テストします。

### 手動プロトタイプのステップ

自動化に投資する前に、手動テストでタスク-モデル適合性を検証します。代表的な入力を1つモデルインターフェースにコピーします。出力の品質を評価します。これは数分で完了し、何時間もの無駄な開発を防ぎます。

この検証は重要な質問に答えます：
- モデルはこのタスクに必要な知識を持っているか？
- モデルは必要な形式で出力を生成できるか？
- 大規模ではどのレベルの品質が期待できるか？
- 対処すべき明らかな失敗モードはあるか？

手動プロトタイプが失敗すれば、自動化されたシステムも失敗します。成功すれば、比較のためのベースラインとプロンプト設計のテンプレートが得られます。

### パイプラインアーキテクチャ

LLMプロジェクトは、各ステージが以下の特性を持つステージ化されたパイプラインアーキテクチャの恩恵を受けます：
- **離散的**：ステージ間の明確な境界
- **冪等**：再実行しても同じ結果を生成
- **キャッシュ可能**：中間結果がディスクに永続化
- **独立**：各ステージが個別に実行可能

**標準的なパイプライン構造：**

```
acquire → prepare → process → parse → render
```

1. **Acquire**：ソース（API、ファイル、データベース）から生データを取得
2. **Prepare**：データをプロンプト形式に変換
3. **Process**：LLM呼び出しを実行（高コストで非決定的なステップ）
4. **Parse**：LLM出力から構造化データを抽出
5. **Render**：最終出力（レポート、ファイル、ビジュアライゼーション）を生成

ステージ1、2、4、5は決定論的です。ステージ3は非決定論的で高コストです。この分離により、必要な場合にのみ高コストなLLMステージを再実行でき、解析とレンダリングを迅速に反復できます。

### ステートマシンとしてのファイルシステム

データベースやインメモリ構造ではなく、ファイルシステムを使用してパイプラインの状態を追跡します。各処理ユニットはディレクトリを取得します。各ステージの完了はファイルの存在によって示されます。

```
data/{id}/
├── raw.json         # acquireステージ完了
├── prompt.md        # prepareステージ完了
├── response.md      # processステージ完了
├── parsed.json      # parseステージ完了
```

アイテムが処理を必要とするかチェックするには：出力ファイルの存在を確認します。ステージを再実行するには：そのステージと下流のファイルを削除します。デバッグするには：中間ファイルを直接読みます。

このパターンが提供するもの：
- 自然な冪等性（ファイルの存在が実行をゲート）
- 容易なデバッグ（すべての状態が人間が読める形式）
- シンプルな並列化（各ディレクトリが独立）
- 簡単なキャッシング（ファイルが実行間で永続化）

### 構造化出力の設計

LLM出力をプログラム的に解析する必要がある場合、プロンプト設計が解析の信頼性を直接決定します。プロンプトは例付きの正確なフォーマット要件を指定する必要があります。

**効果的な構造指定には以下が含まれます：**

1. **セクションマーカー**：解析のための明示的なヘッダーまたはプレフィックス
2. **フォーマット例**：出力がどのように見えるべきかを正確に示す
3. **根拠の開示**：「これをプログラム的に解析します」
4. **制約された値**：列挙されたオプション、スコア範囲、フォーマット

**プロンプト構造の例：**
```
Analyze the following and provide your response in exactly this format:

## Summary
[Your summary here]

## Score
Rating: [1-10]

## Details
- Key point 1
- Key point 2

Follow this format exactly because I will be parsing it programmatically.
```

解析コードはバリエーションを柔軟に処理する必要があります。LLMは指示に完璧に従いません。以下の特性を持つパーサーを構築してください：
- 軽微なフォーマットのバリエーションを処理できる柔軟な正規表現パターンを使用する
- セクションが欠落している場合に適切なデフォルト値を提供する
- クラッシュするのではなく、後のレビューのために解析失敗をログに記録する

### エージェント支援開発

現代のエージェント対応モデルは開発を大幅に加速できます。パターンは以下の通りです：

1. プロジェクトの目標と制約を記述する
2. エージェントに初期実装を生成させる
3. 特定の失敗をテストし反復する
4. 結果に基づいてプロンプトとアーキテクチャを改善する

これは迅速な反復に関するものです：生成、テスト、修正、繰り返し。エージェントがボイラープレートと初期構造を処理し、あなたはドメイン固有の要件とエッジケースに集中します。

効果的なエージェント支援開発の主要なプラクティス：
- 事前に明確で具体的な要件を提供する
- 大規模なプロジェクトを個別のコンポーネントに分割する
- 次に進む前に各コンポーネントをテストする
- エージェントを一度に1つのタスクに集中させる

### コストとスケールの見積もり

LLM処理には予測可能なコストがあり、開始前に見積もるべきです。計算式：

```
Total cost = (items × tokens_per_item × price_per_token) + API overhead
```

バッチ処理の場合：
- アイテムごとの入力トークン（プロンプト + コンテキスト）を見積もる
- アイテムごとの出力トークン（典型的な応答長）を見積もる
- アイテム数を掛ける
- リトライと失敗のために20〜30%のバッファを追加する

開発中の実際のコストを追跡します。コストが見積もりを大幅に超える場合、アプローチを再評価します。以下を検討してください：
- トランケーションによるコンテキスト長の削減
- より単純なアイテムには小さいモデルを使用
- 部分的な結果のキャッシュと再利用
- 実行時間を短縮するための並列処理（トークンコストではない）

## 詳細トピック

### シングル vs マルチエージェントアーキテクチャの選択

シングルエージェントパイプラインが有効な場合：
- 独立したアイテムのバッチ処理
- アイテムが相互作用しないタスク
- よりシンプルなコストと複雑さの管理

マルチエージェントアーキテクチャが有効な場合：
- 異なる側面の並行探索
- 単一のコンテキストウィンドウの容量を超えるタスク
- 専門化されたサブエージェントが品質を向上させる場合

マルチエージェントの主な理由は、ロールの擬人化ではなく、コンテキストの分離です。サブエージェントは、集中したサブタスクのために新しいコンテキストウィンドウを取得します。これにより、長時間実行タスクでのコンテキスト劣化が防止されます。

詳細なアーキテクチャガイダンスについては、`multi-agent-patterns`スキルを参照してください。

### アーキテクチャの簡素化

最小限のアーキテクチャから始めます。複雑さは必要性が証明された場合にのみ追加します。本番環境のエビデンスは、専門ツールを削除することでパフォーマンスが向上することが多いことを示しています。

Vercelのd0エージェントは、17の専門ツールから2つのプリミティブ（bashコマンド実行とSQL）に削減することで、成功率を80%から100%に向上させました。ファイルシステムエージェントパターンは、カスタム探索ツールの代わりに標準Unixユーティリティ（grep、cat、find、ls）を使用します。

**簡素化が複雑さに勝る場合：**
- データレイヤーが十分に文書化され、一貫した構造を持っている
- モデルが十分な推論能力を持っている
- 専門ツールが有効化するのではなく制約している
- 結果の改善よりもスキャフォールディングの保守に多くの時間を費やしている

**複雑さが必要な場合：**
- 基盤データが雑で、一貫性がなく、文書化が不十分
- ドメインにモデルが欠いている専門知識が必要
- 安全性の制約がエージェントの能力を制限する必要がある
- 操作が真に複雑で、構造化されたワークフローの恩恵を受ける

詳細なツールアーキテクチャガイダンスについては、`tool-design`スキルを参照してください。

### 反復とリファクタリング

リファクタリングを覚悟してください。大規模な本番エージェントシステムは、複数のアーキテクチャ反復を必要とします。Manusはローンチ以来、エージェントフレームワークを5回リファクタリングしました。The Bitter Lessonは、現在のモデルの制限のために追加された構造が、モデルが改善されるにつれて制約になることを示唆しています。

変更に備えて構築する：
- アーキテクチャをシンプルで独断的でないものに保つ
- モデルの強みを横断してテストし、ハーネスがパフォーマンスを制限していないことを確認する
- モデルの改善から恩恵を受けるシステムを設計し、制限を固定しない

## 実践ガイダンス

### プロジェクト計画テンプレート

1. **タスク分析**
   - 入力は何か？望ましい出力は何か？
   - これは統合、生成、分類、分析のいずれか？
   - 許容できるエラー率は？
   - 成功した完了ごとの価値は？

2. **手動検証**
   - ターゲットモデルで1つの例をテスト
   - 出力の品質とフォーマットを評価
   - 失敗モードを特定
   - アイテムごとのトークンを見積もる

3. **アーキテクチャ選択**
   - シングルパイプライン vs マルチエージェント
   - 必要なツールとデータソース
   - ストレージとキャッシング戦略
   - 並列化アプローチ

4. **コスト見積もり**
   - アイテム × トークン × 価格
   - 開発時間
   - インフラ要件
   - 継続的な運用コスト

5. **開発計画**
   - ステージごとの実装
   - ステージごとのテスト戦略
   - 反復のマイルストーン
   - デプロイメントアプローチ

### 避けるべきアンチパターン

**手動検証の省略**：モデルがタスクを実行できることを検証する前に自動化を構築すると、アプローチが根本的に欠陥がある場合に大幅な時間の浪費になります。

**モノリシックなパイプライン**：すべてのステージを1つのスクリプトにまとめると、デバッグと反復が困難になります。永続的な中間出力でステージを分離してください。

**モデルの過度な制約**：モデル自体が処理できるガードレール、事前フィルタリング、検証ロジックの追加。スキャフォールディングが助けになるか害になるかテストしてください。

**本番までコストを無視**：トークンコストは大規模に急速に増加します。最初から見積もりと追跡を行ってください。

**完全な解析の要求**：LLMがフォーマット指示に完璧に従うことを期待する。バリエーションを処理する堅牢なパーサーを構築してください。

**早すぎる最適化**：基本的なパイプラインが正しく動作する前に、キャッシュ、並列化、最適化を追加する。

## 例

**例1：バッチ分析パイプライン（KarpathyのHN Time Capsule）**

タスク：10年前の930件のHNディスカッションを後知恵で評価分析。

アーキテクチャ：
- 5ステージパイプライン：fetch → prompt → analyze → parse → render
- ファイルシステム状態：data/{date}/{item_id}/ にステージ出力ファイル
- 構造化出力：明示的なフォーマット要件を持つ6セクション
- 並列実行：LLM呼び出し用に15ワーカー

結果：総コスト$58、実行時間約1時間、静的HTML出力。

**例2：アーキテクチャの簡素化（Vercel d0）**

タスク：内部アナリティクス用のText-to-SQLエージェント。

変更前：17の専門ツール、成功率80%、平均実行時間274秒。

変更後：2つのツール（bash + SQL）、成功率100%、平均実行時間77秒。

重要な洞察：セマンティックレイヤーは既に良い文書化でした。Claudeはファイルを直接読むためのアクセスだけが必要でした。

詳細な分析については、[Case Studies](./references/case-studies.md)を参照してください。

## ガイドライン

1. 自動化を構築する前に手動プロトタイピングでタスク-モデル適合性を検証する
2. パイプラインを離散的で冪等でキャッシュ可能なステージとして構成する
3. 状態管理とデバッグにファイルシステムを使用する
4. 明示的なフォーマット例を持つ構造化された解析可能な出力のためのプロンプトを設計する
5. 最小限のアーキテクチャから始め、必要性が証明された場合にのみ複雑さを追加する
6. 早期にコストを見積もり、開発全体を通じて追跡する
7. LLM出力のバリエーションを処理する堅牢なパーサーを構築する
8. 複数のアーキテクチャ反復を予期し計画する
9. スキャフォールディングがモデルのパフォーマンスを助けるか制約するかテストする
10. 実装の迅速な反復のためにエージェント支援開発を使用する

## 統合

このスキルは以下と接続します：
- context-fundamentals - プロンプト設計のためのコンテキスト制約の理解
- tool-design - パイプライン内のエージェントシステムのためのツール設計
- multi-agent-patterns - マルチエージェントとシングルパイプラインの使い分け
- evaluation - パイプライン出力とエージェントパフォーマンスの評価
- context-compression - パイプラインが制限を超えた場合のコンテキスト管理

## 参考資料

内部参考資料：
- [Case Studies](./references/case-studies.md) - Karpathy HN Capsule、Vercel d0、Manusパターン
- [Pipeline Patterns](./references/pipeline-patterns.md) - 詳細なパイプラインアーキテクチャガイダンス

このコレクションの関連スキル：
- tool-design - ツールアーキテクチャと簡素化パターン
- multi-agent-patterns - マルチエージェントアーキテクチャの使い分け
- evaluation - 出力評価フレームワーク

外部リソース：
- Karpathy's HN Time Capsule project: https://github.com/karpathy/hn-time-capsule
- Vercel d0 architectural reduction: https://vercel.com/blog/we-removed-80-percent-of-our-agents-tools
- Manus context engineering: Peak Jiのコンテキストエンジニアリングに関するブログ
- Anthropic multi-agent research: マルチエージェントリサーチシステムの構築方法

---

## スキルメタデータ

**作成日**: 2025-12-25
**最終更新日**: 2025-12-25
**著者**: Agent Skills for Context Engineering Contributors
**バージョン**: 1.0.0

